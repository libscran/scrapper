% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scoreMarkers.R
\name{scoreMarkers}
\alias{scoreMarkers}
\title{Score marker genes}
\usage{
scoreMarkers(
  x,
  groups,
  block = NULL,
  block.weight.policy = c("variable", "equal", "none"),
  variable.block.weight = c(0, 1000),
  compute.delta.mean = TRUE,
  compute.delta.detected = TRUE,
  compute.cohens.d = TRUE,
  compute.auc = TRUE,
  threshold = 0,
  all.pairwise = FALSE,
  num.threads = 1
)
}
\arguments{
\item{x}{A matrix-like object where rows correspond to genes or genomic features and columns correspond to cells.
It is typically expected to contain log-expression values, e.g., from \code{\link{normalizeCounts}}.}

\item{groups}{A vector specifying the group assignment for each cell in \code{x}.}

\item{block}{Factor specifying the block of origin (e.g., batch, sample) for each cell in \code{x}.
If provided, calculation of means/variances and trend fitting are performed within each block to ensure that block effects do not confound the estimates.
Alternatively, \code{NULL} if all cells are from the same block.}

\item{block.weight.policy}{String specifying the policy to use for weighting different blocks when computing the average for each statistic.
This should be one of:
\itemize{
\item \code{"none"}: the contribution of each block is proportional to its size.
\item \code{"equal"}: blocks are equally weighted regardless of their size.
\item \code{"variable"}: blocks are equally weighted past a certain threshold size.
Below that size, the contribution of each block is proportional to its size.
This avoids outsized contributions from very large blocks.
}
Only used if \code{block} is not \code{NULL}.}

\item{variable.block.weight}{Numeric vector of length 2, specifying the parameters for variable block weighting.
The first value is usually zero and defines the threshold on the size at or below which a block receives zero weight.
The second value is the upper threshold on the size above which all blocks have the same weight.
Only used if \code{block} is not \code{NULL} and \code{block.weight.policy = "variable"}.}

\item{compute.delta.mean}{Logical scalar indicating whether to compute the delta-means, i.e., the log-fold change when \code{x} contains log-expression values.}

\item{compute.delta.detected}{Logical scalar indicating whether to compute the delta-detected, i.e., differences in the proportion of cells with detected expression.}

\item{compute.cohens.d}{Logical scalar indicating whether to compute Cohen's d.}

\item{compute.auc}{Logical scalar indicating whether to compute the AUC.
Setting this to \code{FALSE} can improve speed and memory efficiency.}

\item{threshold}{Non-negative numeric scalar specifying the minimum threshold on the differences in means (i.e., the log-fold change, if \code{x} contains log-expression values). 
This is incorporated into the effect sizes for Cohen's d and the AUC.}

\item{all.pairwise}{Logical scalar indicating whether to report the full effects for every pairwise comparison between groups.}

\item{num.threads}{Integer scalar specifying the number of threads to use.}
}
\value{
If \code{all.pairwise=FALSE}, a named list is returned containing:
\itemize{
\item \code{mean}, a numeric matrix containing the mean expression for each group.
Each row is a gene and each column is a group.
\item \code{detected}, a numeric matrix containing the proportion of detected cells in each group.
Each row is a gene and each column is a group.
\item \code{cohens.d}, a list of data frames where each data frame corresponds to a group.
Each row of each data frame represents a gene, while each column contains a summary of Cohen's d from pairwise comparisons to all other groups.
This includes the \code{min}, \code{mean}, \code{median}, \code{max} and \code{min.rank} - check out \code{?\link{summarizeEffects}} for details.
Omitted if \code{compute.cohens.d=FALSE}.
\item \code{auc}, a list like \code{cohens.d} but containing the summaries of the AUCs from each pairwise comparison.
Omitted if \code{compute.auc=FALSE}.
\item \code{delta.mean}, a list like \code{cohens.d} but containing the summaries of the delta-mean from each pairwise comparison.
Omitted if \code{compute.delta.mean=FALSE}.
\item \code{delta.detected}, a list like \code{cohens.d} but containing the summaries of the delta-detected from each pairwise comparison.
Omitted if \code{compute.delta.detected=FALSE}.
}

If \code{all.pairwise=TRUE}, a list is returned containing:
\itemize{
\item \code{mean}, a numeric matrix containing the mean expression for each group.
Each row is a gene and each column is a group.
\item \code{detected}, a numeric matrix containing the proportion of detected cells in each group.
Each row is a gene and each column is a group.
\item \code{cohens.d}, a 3-dimensional numeric array containing the Cohen's d from each pairwise comparison between groups.
The extents of the first two dimensions are equal to the number of groups, while the extent of the final dimension is equal to the number of genes.
The entry \code{[i, j, k]} represents Cohen's d from the comparison of group \code{j} over group \code{i} for gene \code{k}.
Omitted if \code{compute.cohens.d=FALSE}.
\item \code{auc}, an array like \code{cohens.d} but containing the AUCs from each pairwise comparison.
Omitted if \code{compute.auc=FALSE}.
\item \code{delta.mean}, an array like \code{cohens.d} but containing the delta-mean from each pairwise comparison.
Omitted if \code{compute.delta.mean=FALSE}.
\item \code{delta.detected}, an array like \code{cohens.d} but containing the delta-detected from each pairwise comparison.
Omitted if \code{compute.delta.detected=FALSE}.
}
}
\description{
Score marker genes for each group using a variety of effect sizes from pairwise comparisons between groups.
This includes Cohen's d, the area under the curve (AUC), the difference in the means (delta-mean) and the difference in the proportion of detected cells (delta-detected).
}
\examples{
# Mocking a matrix:
library(Matrix)
x <- round(abs(rsparsematrix(1000, 100, 0.1) * 100))
normed <- normalizeCounts(x, size.factors=centerSizeFactors(colSums(x)))

# Compute marker summaries for each group:
g <- sample(letters[1:4], ncol(x), replace=TRUE)
scores <- scoreMarkers(normed, g)
names(scores)
head(scores$mean)
head(scores$cohens.d[["a"]])

# Report marker statistics for a single group:
reportGroupMarkerStatistics(scores, "b")

}
\seealso{
The \code{score_markers_summary} and the \code{score_markers_pairwise} function (for \code{all.pairwise=FALSE} and \code{TRUE}, respectively) in \url{https://libscran.github.io/scran_markers/},
which describes the rationale behind the choice of effect sizes and summary statistics.
Also see their blocked equivalents \code{score_markers_summary_blocked} and \code{score_markers_pairwise_blocked} when \code{block} is not \code{NULL}.

\code{\link{summarizeEffects}}, to summarize the pairwise effects returned when \code{all.pairwise=TRUE}.

\code{\link{reportGroupMarkerStatistics}}, to consolidate the statistics for a single group into its own data frame.
}
